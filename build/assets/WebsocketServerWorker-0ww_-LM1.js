function L(n){const e=n.length;let t=0,i=0;for(;i<e;){let s=n.charCodeAt(i++);if((s&4294967168)===0){t++;continue}else if((s&4294965248)===0)t+=2;else{if(s>=55296&&s<=56319&&i<e){const o=n.charCodeAt(i);(o&64512)===56320&&(++i,s=((s&1023)<<10)+(o&1023)+65536)}(s&4294901760)===0?t+=3:t+=4}}return t}function M(n,e,t){const i=n.length;let s=t,o=0;for(;o<i;){let r=n.charCodeAt(o++);if((r&4294967168)===0){e[s++]=r;continue}else if((r&4294965248)===0)e[s++]=r>>6&31|192;else{if(r>=55296&&r<=56319&&o<i){const h=n.charCodeAt(o);(h&64512)===56320&&(++o,r=((r&1023)<<10)+(h&1023)+65536)}(r&4294901760)===0?(e[s++]=r>>12&15|224,e[s++]=r>>6&63|128):(e[s++]=r>>18&7|240,e[s++]=r>>12&63|128,e[s++]=r>>6&63|128)}e[s++]=r&63|128}}const P=new TextEncoder,C=50;function F(n,e,t){P.encodeInto(n,e.subarray(t))}function $(n,e,t){n.length>C?F(n,e,t):M(n,e,t)}const R=4096;function v(n,e,t){let i=e;const s=i+t,o=[];let r="";for(;i<s;){const h=n[i++];if((h&128)===0)o.push(h);else if((h&224)===192){const a=n[i++]&63;o.push((h&31)<<6|a)}else if((h&240)===224){const a=n[i++]&63,c=n[i++]&63;o.push((h&31)<<12|a<<6|c)}else if((h&248)===240){const a=n[i++]&63,c=n[i++]&63,p=n[i++]&63;let l=(h&7)<<18|a<<12|c<<6|p;l>65535&&(l-=65536,o.push(l>>>10&1023|55296),l=56320|l&1023),o.push(l)}else o.push(h);o.length>=R&&(r+=String.fromCharCode(...o),o.length=0)}return o.length>0&&(r+=String.fromCharCode(...o)),r}const H=new TextDecoder,K=200;function W(n,e,t){const i=n.subarray(e,e+t);return H.decode(i)}function b(n,e,t){return t>K?W(n,e,t):v(n,e,t)}class y{constructor(e,t){this.type=e,this.data=t}}class f extends Error{constructor(e){super(e);const t=Object.create(f.prototype);Object.setPrototypeOf(this,t),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:f.name})}}const u=4294967295;function N(n,e,t){const i=t/4294967296,s=t;n.setUint32(e,i),n.setUint32(e+4,s)}function k(n,e,t){const i=Math.floor(t/4294967296),s=t;n.setUint32(e,i),n.setUint32(e+4,s)}function z(n,e){const t=n.getInt32(e),i=n.getUint32(e+4);return t*4294967296+i}function V(n,e){const t=n.getUint32(e),i=n.getUint32(e+4);return t*4294967296+i}const q=-1,O=4294967296-1,X=17179869184-1;function Y({sec:n,nsec:e}){if(n>=0&&e>=0&&n<=X)if(e===0&&n<=O){const t=new Uint8Array(4);return new DataView(t.buffer).setUint32(0,n),t}else{const t=n/4294967296,i=n&4294967295,s=new Uint8Array(8),o=new DataView(s.buffer);return o.setUint32(0,e<<2|t&3),o.setUint32(4,i),s}else{const t=new Uint8Array(12),i=new DataView(t.buffer);return i.setUint32(0,e),k(i,4,n),t}}function G(n){const e=n.getTime(),t=Math.floor(e/1e3),i=(e-t*1e3)*1e6,s=Math.floor(i/1e9);return{sec:t+s,nsec:i-s*1e9}}function J(n){if(n instanceof Date){const e=G(n);return Y(e)}else return null}function Z(n){const e=new DataView(n.buffer,n.byteOffset,n.byteLength);switch(n.byteLength){case 4:return{sec:e.getUint32(0),nsec:0};case 8:{const t=e.getUint32(0),i=e.getUint32(4),s=(t&3)*4294967296+i,o=t>>>2;return{sec:s,nsec:o}}case 12:{const t=z(e,4),i=e.getUint32(0);return{sec:t,nsec:i}}default:throw new f(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${n.length}`)}}function Q(n){const e=Z(n);return new Date(e.sec*1e3+e.nsec/1e6)}const j={type:q,encode:J,decode:Q};class g{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(j)}register({type:e,encode:t,decode:i}){if(e>=0)this.encoders[e]=t,this.decoders[e]=i;else{const s=-1-e;this.builtInEncoders[s]=t,this.builtInDecoders[s]=i}}tryToEncode(e,t){for(let i=0;i<this.builtInEncoders.length;i++){const s=this.builtInEncoders[i];if(s!=null){const o=s(e,t);if(o!=null){const r=-1-i;return new y(r,o)}}}for(let i=0;i<this.encoders.length;i++){const s=this.encoders[i];if(s!=null){const o=s(e,t);if(o!=null){const r=i;return new y(r,o)}}}return e instanceof y?e:null}decode(e,t,i){const s=t<0?this.builtInDecoders[-1-t]:this.decoders[t];return s?s(e,t,i):new y(t,e)}}g.defaultCodec=new g;function ee(n){return n instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&n instanceof SharedArrayBuffer}function m(n){return n instanceof Uint8Array?n:ArrayBuffer.isView(n)?new Uint8Array(n.buffer,n.byteOffset,n.byteLength):ee(n)?new Uint8Array(n):Uint8Array.from(n)}const te=100,ie=2048;class E{constructor(e){this.entered=!1,this.extensionCodec=e?.extensionCodec??g.defaultCodec,this.context=e?.context,this.useBigInt64=e?.useBigInt64??!1,this.maxDepth=e?.maxDepth??te,this.initialBufferSize=e?.initialBufferSize??ie,this.sortKeys=e?.sortKeys??!1,this.forceFloat32=e?.forceFloat32??!1,this.ignoreUndefined=e?.ignoreUndefined??!1,this.forceIntegerToFloat=e?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new E({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(e){if(this.entered)return this.clone().encodeSharedRef(e);try{return this.entered=!0,this.reinitializeState(),this.doEncode(e,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(e){if(this.entered)return this.clone().encode(e);try{return this.entered=!0,this.reinitializeState(),this.doEncode(e,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(e,t){if(t>this.maxDepth)throw new Error(`Too deep objects in depth ${t}`);e==null?this.encodeNil():typeof e=="boolean"?this.encodeBoolean(e):typeof e=="number"?this.forceIntegerToFloat?this.encodeNumberAsFloat(e):this.encodeNumber(e):typeof e=="string"?this.encodeString(e):this.useBigInt64&&typeof e=="bigint"?this.encodeBigInt64(e):this.encodeObject(e,t)}ensureBufferSizeToWrite(e){const t=this.pos+e;this.view.byteLength<t&&this.resizeBuffer(t*2)}resizeBuffer(e){const t=new ArrayBuffer(e),i=new Uint8Array(t),s=new DataView(t);i.set(this.bytes),this.view=s,this.bytes=i}encodeNil(){this.writeU8(192)}encodeBoolean(e){e===!1?this.writeU8(194):this.writeU8(195)}encodeNumber(e){!this.forceIntegerToFloat&&Number.isSafeInteger(e)?e>=0?e<128?this.writeU8(e):e<256?(this.writeU8(204),this.writeU8(e)):e<65536?(this.writeU8(205),this.writeU16(e)):e<4294967296?(this.writeU8(206),this.writeU32(e)):this.useBigInt64?this.encodeNumberAsFloat(e):(this.writeU8(207),this.writeU64(e)):e>=-32?this.writeU8(224|e+32):e>=-128?(this.writeU8(208),this.writeI8(e)):e>=-32768?(this.writeU8(209),this.writeI16(e)):e>=-2147483648?(this.writeU8(210),this.writeI32(e)):this.useBigInt64?this.encodeNumberAsFloat(e):(this.writeU8(211),this.writeI64(e)):this.encodeNumberAsFloat(e)}encodeNumberAsFloat(e){this.forceFloat32?(this.writeU8(202),this.writeF32(e)):(this.writeU8(203),this.writeF64(e))}encodeBigInt64(e){e>=BigInt(0)?(this.writeU8(207),this.writeBigUint64(e)):(this.writeU8(211),this.writeBigInt64(e))}writeStringHeader(e){if(e<32)this.writeU8(160+e);else if(e<256)this.writeU8(217),this.writeU8(e);else if(e<65536)this.writeU8(218),this.writeU16(e);else if(e<4294967296)this.writeU8(219),this.writeU32(e);else throw new Error(`Too long string: ${e} bytes in UTF-8`)}encodeString(e){const i=L(e);this.ensureBufferSizeToWrite(5+i),this.writeStringHeader(i),$(e,this.bytes,this.pos),this.pos+=i}encodeObject(e,t){const i=this.extensionCodec.tryToEncode(e,this.context);if(i!=null)this.encodeExtension(i);else if(Array.isArray(e))this.encodeArray(e,t);else if(ArrayBuffer.isView(e))this.encodeBinary(e);else if(typeof e=="object")this.encodeMap(e,t);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(e)}`)}encodeBinary(e){const t=e.byteLength;if(t<256)this.writeU8(196),this.writeU8(t);else if(t<65536)this.writeU8(197),this.writeU16(t);else if(t<4294967296)this.writeU8(198),this.writeU32(t);else throw new Error(`Too large binary: ${t}`);const i=m(e);this.writeU8a(i)}encodeArray(e,t){const i=e.length;if(i<16)this.writeU8(144+i);else if(i<65536)this.writeU8(220),this.writeU16(i);else if(i<4294967296)this.writeU8(221),this.writeU32(i);else throw new Error(`Too large array: ${i}`);for(const s of e)this.doEncode(s,t+1)}countWithoutUndefined(e,t){let i=0;for(const s of t)e[s]!==void 0&&i++;return i}encodeMap(e,t){const i=Object.keys(e);this.sortKeys&&i.sort();const s=this.ignoreUndefined?this.countWithoutUndefined(e,i):i.length;if(s<16)this.writeU8(128+s);else if(s<65536)this.writeU8(222),this.writeU16(s);else if(s<4294967296)this.writeU8(223),this.writeU32(s);else throw new Error(`Too large map object: ${s}`);for(const o of i){const r=e[o];this.ignoreUndefined&&r===void 0||(this.encodeString(o),this.doEncode(r,t+1))}}encodeExtension(e){if(typeof e.data=="function"){const i=e.data(this.pos+6),s=i.length;if(s>=4294967296)throw new Error(`Too large extension object: ${s}`);this.writeU8(201),this.writeU32(s),this.writeI8(e.type),this.writeU8a(i);return}const t=e.data.length;if(t===1)this.writeU8(212);else if(t===2)this.writeU8(213);else if(t===4)this.writeU8(214);else if(t===8)this.writeU8(215);else if(t===16)this.writeU8(216);else if(t<256)this.writeU8(199),this.writeU8(t);else if(t<65536)this.writeU8(200),this.writeU16(t);else if(t<4294967296)this.writeU8(201),this.writeU32(t);else throw new Error(`Too large extension object: ${t}`);this.writeI8(e.type),this.writeU8a(e.data)}writeU8(e){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,e),this.pos++}writeU8a(e){const t=e.length;this.ensureBufferSizeToWrite(t),this.bytes.set(e,this.pos),this.pos+=t}writeI8(e){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,e),this.pos++}writeU16(e){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,e),this.pos+=2}writeI16(e){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,e),this.pos+=2}writeU32(e){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,e),this.pos+=4}writeI32(e){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,e),this.pos+=4}writeF32(e){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,e),this.pos+=4}writeF64(e){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,e),this.pos+=8}writeU64(e){this.ensureBufferSizeToWrite(8),N(this.view,this.pos,e),this.pos+=8}writeI64(e){this.ensureBufferSizeToWrite(8),k(this.view,this.pos,e),this.pos+=8}writeBigUint64(e){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,e),this.pos+=8}writeBigInt64(e){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,e),this.pos+=8}}function se(n,e){return new E(e).encodeSharedRef(n)}function U(n){return`${n<0?"-":""}0x${Math.abs(n).toString(16).padStart(2,"0")}`}const ne=16,re=16;class oe{constructor(e=ne,t=re){this.hit=0,this.miss=0,this.maxKeyLength=e,this.maxLengthPerKey=t,this.caches=[];for(let i=0;i<this.maxKeyLength;i++)this.caches.push([])}canBeCached(e){return e>0&&e<=this.maxKeyLength}find(e,t,i){const s=this.caches[i-1];e:for(const o of s){const r=o.bytes;for(let h=0;h<i;h++)if(r[h]!==e[t+h])continue e;return o.str}return null}store(e,t){const i=this.caches[e.length-1],s={bytes:e,str:t};i.length>=this.maxLengthPerKey?i[Math.random()*i.length|0]=s:i.push(s)}decode(e,t,i){const s=this.find(e,t,i);if(s!=null)return this.hit++,s;this.miss++;const o=v(e,t,i),r=Uint8Array.prototype.slice.call(e,t,t+i);return this.store(r,o),o}}const S="array",x="map_key",_="map_value",he=n=>{if(typeof n=="string"||typeof n=="number")return n;throw new f("The type of key must be string or number but "+typeof n)};class ae{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(e){const t=this.getUninitializedStateFromPool();t.type=S,t.position=0,t.size=e,t.array=new Array(e)}pushMapState(e){const t=this.getUninitializedStateFromPool();t.type=x,t.readCount=0,t.size=e,t.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const e={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(e)}return this.stack[this.stackHeadPosition]}release(e){if(this.stack[this.stackHeadPosition]!==e)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(e.type===S){const i=e;i.size=0,i.array=void 0,i.position=0,i.type=void 0}if(e.type===x||e.type===_){const i=e;i.size=0,i.map=void 0,i.readCount=0,i.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}const w=-1,B=new DataView(new ArrayBuffer(0)),ce=new Uint8Array(B.buffer);try{B.getInt8(0)}catch(n){if(!(n instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}const T=new RangeError("Insufficient data"),fe=new oe;class A{constructor(e){this.totalPos=0,this.pos=0,this.view=B,this.bytes=ce,this.headByte=w,this.stack=new ae,this.entered=!1,this.extensionCodec=e?.extensionCodec??g.defaultCodec,this.context=e?.context,this.useBigInt64=e?.useBigInt64??!1,this.rawStrings=e?.rawStrings??!1,this.maxStrLength=e?.maxStrLength??u,this.maxBinLength=e?.maxBinLength??u,this.maxArrayLength=e?.maxArrayLength??u,this.maxMapLength=e?.maxMapLength??u,this.maxExtLength=e?.maxExtLength??u,this.keyDecoder=e?.keyDecoder!==void 0?e.keyDecoder:fe,this.mapKeyConverter=e?.mapKeyConverter??he}clone(){return new A({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=w,this.stack.reset()}setBuffer(e){const t=m(e);this.bytes=t,this.view=new DataView(t.buffer,t.byteOffset,t.byteLength),this.pos=0}appendBuffer(e){if(this.headByte===w&&!this.hasRemaining(1))this.setBuffer(e);else{const t=this.bytes.subarray(this.pos),i=m(e),s=new Uint8Array(t.length+i.length);s.set(t),s.set(i,t.length),this.setBuffer(s)}}hasRemaining(e){return this.view.byteLength-this.pos>=e}createExtraByteError(e){const{view:t,pos:i}=this;return new RangeError(`Extra ${t.byteLength-i} of ${t.byteLength} byte(s) found at buffer[${e}]`)}decode(e){if(this.entered)return this.clone().decode(e);try{this.entered=!0,this.reinitializeState(),this.setBuffer(e);const t=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return t}finally{this.entered=!1}}*decodeMulti(e){if(this.entered){yield*this.clone().decodeMulti(e);return}try{for(this.entered=!0,this.reinitializeState(),this.setBuffer(e);this.hasRemaining(1);)yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(e){if(this.entered)return this.clone().decodeAsync(e);try{this.entered=!0;let t=!1,i;for await(const h of e){if(t)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(h);try{i=this.doDecodeSync(),t=!0}catch(a){if(!(a instanceof RangeError))throw a}this.totalPos+=this.pos}if(t){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return i}const{headByte:s,pos:o,totalPos:r}=this;throw new RangeError(`Insufficient data in parsing ${U(s)} at ${r} (${o} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(e){return this.decodeMultiAsync(e,!0)}decodeStream(e){return this.decodeMultiAsync(e,!1)}async*decodeMultiAsync(e,t){if(this.entered){yield*this.clone().decodeMultiAsync(e,t);return}try{this.entered=!0;let i=t,s=-1;for await(const o of e){if(t&&s===0)throw this.createExtraByteError(this.totalPos);this.appendBuffer(o),i&&(s=this.readArraySize(),i=!1,this.complete());try{for(;yield this.doDecodeSync(),--s!==0;);}catch(r){if(!(r instanceof RangeError))throw r}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){e:for(;;){const e=this.readHeadByte();let t;if(e>=224)t=e-256;else if(e<192)if(e<128)t=e;else if(e<144){const s=e-128;if(s!==0){this.pushMapState(s),this.complete();continue e}else t={}}else if(e<160){const s=e-144;if(s!==0){this.pushArrayState(s),this.complete();continue e}else t=[]}else{const s=e-160;t=this.decodeString(s,0)}else if(e===192)t=null;else if(e===194)t=!1;else if(e===195)t=!0;else if(e===202)t=this.readF32();else if(e===203)t=this.readF64();else if(e===204)t=this.readU8();else if(e===205)t=this.readU16();else if(e===206)t=this.readU32();else if(e===207)this.useBigInt64?t=this.readU64AsBigInt():t=this.readU64();else if(e===208)t=this.readI8();else if(e===209)t=this.readI16();else if(e===210)t=this.readI32();else if(e===211)this.useBigInt64?t=this.readI64AsBigInt():t=this.readI64();else if(e===217){const s=this.lookU8();t=this.decodeString(s,1)}else if(e===218){const s=this.lookU16();t=this.decodeString(s,2)}else if(e===219){const s=this.lookU32();t=this.decodeString(s,4)}else if(e===220){const s=this.readU16();if(s!==0){this.pushArrayState(s),this.complete();continue e}else t=[]}else if(e===221){const s=this.readU32();if(s!==0){this.pushArrayState(s),this.complete();continue e}else t=[]}else if(e===222){const s=this.readU16();if(s!==0){this.pushMapState(s),this.complete();continue e}else t={}}else if(e===223){const s=this.readU32();if(s!==0){this.pushMapState(s),this.complete();continue e}else t={}}else if(e===196){const s=this.lookU8();t=this.decodeBinary(s,1)}else if(e===197){const s=this.lookU16();t=this.decodeBinary(s,2)}else if(e===198){const s=this.lookU32();t=this.decodeBinary(s,4)}else if(e===212)t=this.decodeExtension(1,0);else if(e===213)t=this.decodeExtension(2,0);else if(e===214)t=this.decodeExtension(4,0);else if(e===215)t=this.decodeExtension(8,0);else if(e===216)t=this.decodeExtension(16,0);else if(e===199){const s=this.lookU8();t=this.decodeExtension(s,1)}else if(e===200){const s=this.lookU16();t=this.decodeExtension(s,2)}else if(e===201){const s=this.lookU32();t=this.decodeExtension(s,4)}else throw new f(`Unrecognized type byte: ${U(e)}`);this.complete();const i=this.stack;for(;i.length>0;){const s=i.top();if(s.type===S)if(s.array[s.position]=t,s.position++,s.position===s.size)t=s.array,i.release(s);else continue e;else if(s.type===x){if(t==="__proto__")throw new f("The key __proto__ is not allowed");s.key=this.mapKeyConverter(t),s.type=_;continue e}else if(s.map[s.key]=t,s.readCount++,s.readCount===s.size)t=s.map,i.release(s);else{s.key=null,s.type=x;continue e}}return t}}readHeadByte(){return this.headByte===w&&(this.headByte=this.readU8()),this.headByte}complete(){this.headByte=w}readArraySize(){const e=this.readHeadByte();switch(e){case 220:return this.readU16();case 221:return this.readU32();default:{if(e<160)return e-144;throw new f(`Unrecognized array type byte: ${U(e)}`)}}}pushMapState(e){if(e>this.maxMapLength)throw new f(`Max length exceeded: map length (${e}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(e)}pushArrayState(e){if(e>this.maxArrayLength)throw new f(`Max length exceeded: array length (${e}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(e)}decodeString(e,t){return!this.rawStrings||this.stateIsMapKey()?this.decodeUtf8String(e,t):this.decodeBinary(e,t)}decodeUtf8String(e,t){if(e>this.maxStrLength)throw new f(`Max length exceeded: UTF-8 byte length (${e}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+t+e)throw T;const i=this.pos+t;let s;return this.stateIsMapKey()&&this.keyDecoder?.canBeCached(e)?s=this.keyDecoder.decode(this.bytes,i,e):s=b(this.bytes,i,e),this.pos+=t+e,s}stateIsMapKey(){return this.stack.length>0?this.stack.top().type===x:!1}decodeBinary(e,t){if(e>this.maxBinLength)throw new f(`Max length exceeded: bin length (${e}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(e+t))throw T;const i=this.pos+t,s=this.bytes.subarray(i,i+e);return this.pos+=t+e,s}decodeExtension(e,t){if(e>this.maxExtLength)throw new f(`Max length exceeded: ext length (${e}) > maxExtLength (${this.maxExtLength})`);const i=this.view.getInt8(this.pos+t),s=this.decodeBinary(e,t+1);return this.extensionCodec.decode(s,i,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const e=this.view.getUint8(this.pos);return this.pos++,e}readI8(){const e=this.view.getInt8(this.pos);return this.pos++,e}readU16(){const e=this.view.getUint16(this.pos);return this.pos+=2,e}readI16(){const e=this.view.getInt16(this.pos);return this.pos+=2,e}readU32(){const e=this.view.getUint32(this.pos);return this.pos+=4,e}readI32(){const e=this.view.getInt32(this.pos);return this.pos+=4,e}readU64(){const e=V(this.view,this.pos);return this.pos+=8,e}readI64(){const e=z(this.view,this.pos);return this.pos+=8,e}readU64AsBigInt(){const e=this.view.getBigUint64(this.pos);return this.pos+=8,e}readI64AsBigInt(){const e=this.view.getBigInt64(this.pos);return this.pos+=8,e}readF32(){const e=this.view.getFloat32(this.pos);return this.pos+=4,e}readF64(){const e=this.view.getFloat64(this.pos);return this.pos+=8,e}}function de(n,e){return new A(e).decode(n)}function le(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var d={},I;function ue(){if(I)return d;I=1;var n=d&&d.__classPrivateFieldGet||function(o,r,h,a){if(h==="a"&&!a)throw new TypeError("Private accessor was defined without a getter");if(typeof r=="function"?o!==r||!a:!r.has(o))throw new TypeError("Cannot read private member from an object whose class did not declare it");return h==="m"?a:h==="a"?a.call(o):a?a.value:r.get(o)},e=d&&d.__classPrivateFieldSet||function(o,r,h,a,c){if(a==="m")throw new TypeError("Private method is not writable");if(a==="a"&&!c)throw new TypeError("Private accessor was defined without a setter");if(typeof r=="function"?o!==r||!c:!r.has(o))throw new TypeError("Cannot write private member to an object whose class did not declare it");return a==="a"?c.call(o,h):c?c.value=h:r.set(o,h),h},t,i;Object.defineProperty(d,"__esModule",{value:!0});class s{constructor(){t.set(this,!1),i.set(this,new Set)}get acquired(){return n(this,t,"f")}acquireAsync({timeout:r}={}){if(!n(this,t,"f"))return e(this,t,!0,"f"),Promise.resolve();if(r==null)return new Promise(c=>{n(this,i,"f").add(c)});let h,a;return Promise.race([new Promise(c=>{h=()=>{clearTimeout(a),c()},n(this,i,"f").add(h)}),new Promise((c,p)=>{a=setTimeout(()=>{n(this,i,"f").delete(h),p(new Error("Timed out waiting for lock"))},r)})])}tryAcquire(){return n(this,t,"f")?!1:(e(this,t,!0,"f"),!0)}release(){if(!n(this,t,"f"))throw new Error("Cannot release an unacquired lock");if(n(this,i,"f").size>0){const[r]=n(this,i,"f");n(this,i,"f").delete(r),r()}else e(this,t,!1,"f")}}return d.default=s,t=new WeakMap,i=new WeakMap,d}var we=ue(),xe=le(we);function D(n,e){if(n instanceof ArrayBuffer)e.add(n);else if(n instanceof Uint8Array)e.add(n.buffer);else if(n&&typeof n=="object")for(const t in n)Object.prototype.hasOwnProperty.call(n,t)&&D(n[t],e);return e}{let n=null,e=null;const t=new xe,i=(o,r)=>{self.postMessage(o,r)},s=()=>{e!==null&&e.close(),e=new WebSocket(n);const o=setTimeout(()=>{e?.close()},5e3);e.onopen=()=>{i({type:"connected"}),clearTimeout(o),console.log(`Connected! ${n}`)},e.onclose=r=>{i({type:"closed"}),console.log(`Disconnected! ${n} code=${r.code}`),clearTimeout(o),n!==null&&requestAnimationFrame(()=>{setTimeout(s,1e3)})},e.onmessage=async r=>{const h=new Promise(a=>{r.data.arrayBuffer().then(c=>{a(de(new Uint8Array(c)))})});await t.acquireAsync({timeout:1e3}).catch(()=>{console.log("Order lock timed out."),t.release()});try{const a=await h,c=D(a,new Set);i({type:"message_batch",messages:a},Array.from(c))}finally{t.acquired&&t.release()}}};self.onmessage=o=>{const r=o.data;r.type==="send"?e.send(se(r.message)):r.type==="set_server"?(n=r.server,s()):r.type=="close"?(n=null,e!==null&&e.close(),self.close()):console.log(`WebSocket worker: got ${r}, not sure what to do with it!`)}}
